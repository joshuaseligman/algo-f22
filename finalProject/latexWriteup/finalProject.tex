%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% CMPT 435
% Fall 2022
% Final Project
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Short Sectioned Assignment
% LaTeX Template
% Version 1.0 (5/5/12)
%
% This template has been downloaded from: http://www.LaTeXTemplates.com
% Original author: % Frits Wenneker (http://www.howtotex.com)
% License: CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
% Modified by Alan G. Labouseur  - alan@labouseur.com
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[letterpaper, 10pt,DIV=13]{scrartcl} 

\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\usepackage[english]{babel} % English language/hyphenation
\usepackage{amsmath,amsfonts,amsthm,xfrac} % Math packages
\usepackage{sectsty} % Allows customizing section commands
\usepackage{graphicx}
\usepackage{algorithm, algpseudocode}
\usepackage{listings}
\usepackage{parskip}
\usepackage{lastpage}
\usepackage{color}
\usepackage{qtree}
\usepackage{xcolor}
\usepackage{colortbl}

\allsectionsfont{\normalfont\scshape} % Make all section titles in default font and small caps.

\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers

\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{page \thepage\ of \pageref{LastPage}} % Page numbering for right footer

\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{13.6pt} % Customize the height of the header

\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

\setlength\parindent{0pt} % Removes all indentation from paragraphs.

\binoppenalty=3000
\relpenalty=3000

\algrenewcommand{\algorithmiccomment}[1]{\hskip1em\textit{$//$ #1}}

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} % Create horizontal rule command with 1 argument of height

\title{	
   \normalfont \normalsize 
   \textsc{CMPT 435 - Fall 2022 - Dr. Labouseur} \\[10pt] % Header stuff.
   \horrule{0.5pt} \\[0.25cm] 	% Top horizontal rule
   \huge Final Project  \\     	    % Assignment title
   \horrule{0.5pt} \\[0.25cm] 	% Bottom horizontal rule
}

\author{Josh Seligman \\ \normalsize joshua.seligman1@marist.edu}

\date{\normalsize\today} 	% Today's date.

\begin{document}
\maketitle % Print the title

\section{Hospitals and Residents Stable Matching Problem}
\subsection{The Algorithm}
In the hospitals and residents stable matching problem, the goal is to assign residents to hospitals given the preferences of both sides so that all assignments are stable. In this context, the term "stability" means that for each resident, there is no hospital that is available that is higher on a resident's list compared to that resident's current assignment. The reason stability is in the terms of the residents is because the residents propose to the hospitals on their preference lists and the hospitals have the ability to either provisionally accept or reject the residents based on their resident preferences and current capacity. In other words, hospitals may have a preferred resident that is available, but that resident may not want to go to that hospital and, therefore, will end up elsewhere.

\begin{algorithm}
  \caption{Hospitals and Residents Stable Matching Algorithm}
  \label{algorithm:original}
  %Documentation for algorithmicx: https://texdoc.org/serve/algorithmicx/0
  \begin{algorithmic}[1]
      \Procedure{StableMatchOriginal}{$residents$, $hospitals$}
        \For{$r~of~residents$}
            \State $r.assignment \gets null$ \Comment{Residents start off unassigned}
        \EndFor
        \For{$h~of~hospitals$}
            \State $h.assignments \gets [~]$ \Comment{Hospitals initially have no assignments}
        \EndFor
        \While{$!residents.isEmpty()$}
            \State $r \gets residents.dequeue()$ \Comment{Get the next resident in line to be assigned}
            \While{$r.assignment == null~\&\&~!r.preferences.isEmpty()$}
                \State $h \gets r.preferences.dequeue()$ \Comment{Try the resident's next top preference}
                \If{$h.isFull()$}
                    \State $r^\prime \gets h.getLeastPreferredAssignedResident()$
                    \State $r^\prime.assignment \gets null$ \Comment{Set the least preferred assigned resident to be free}
                    \State $residents.enqueue(r)$ \Comment{Add the resident back to the list to be reassigned}
                \EndIf
                \State $r.assignment \gets h$ \Comment{Provisionally assign r to h}
                \If{$h.isFull()$}
                    \State $s \gets h.getLeastPreferredAssignedResident()$
                    \For {$i \gets h.preferences.indexOf(s) + 1,~len(h.preferences) - 1$}
                        \State $s^\prime \gets h.preferences[i]$
                        \State $s^\prime.preferences.remove(h)$ \Comment{Remove h from preferences of $s^\prime$}
                        \State $h.preferences.remove(s^\prime)$ \Comment{Remove $s^\prime$ from preferences of h}
                    \EndFor
                \EndIf
            \EndWhile
        \EndWhile
      \EndProcedure
  \end{algorithmic}
\end{algorithm}

\subsection{Asymptotic Analysis}
The pseudocode for the hospitals and residents stable matching algorithm is provided in Algorithm \ref{algorithm:original}. The algorithm starts off by assigning all residents and hospitals to be completely free, which are $O(r)$ and $O(h)$ operations, respectively. Next, line 8 is the condition for a while loop that runs until the residents list is empty. Since residents are being picked off one-by-one as done in line 9, the loop will run for each resident, which makes it run on average $r$ times. Line 10, similar to line 8, also defines a while loop. This time, however, it is iterating over the resident's preferences, which means the while loop runs $h$ times for each iteration of the outer loop. The if-statement block on lines 12-16 is inside of the inner loop, and contains a statement to get the least preferred assigned resident, which is an $O(r)$ operation as it may have to loop through all of the residents at worst case. The condition and other 2 assignments in the if-statement block are constant time assignments. The assignment on line 17 sets the assignment for the resident, which runs in constant time. Next, just like line 12, the check if the hospital is full a constant time check. Line 19 is the same as line 13 and is an $O(r)$ operation. Next, there is a loop defined on line 20 that iterates through the remaining residents in the list of hospital preferences, which at worst case is about $r$ iterations. It also has an $O(r)$ operation that is executed once to get the starting index. Lastly, there is a constant time assignment on line 21, and the removal function calls are $O(h)$ and $O(r)$ operations, respectively, as the hospitals and residents are being iterated through in each call. Overall, when putting it all together, the runtime of the original stable matching problem for residents and hospitals is $r * h * (r + r + r * (h + r)) = rh * (2r + rh + r^2) = 2r^2h + r^2h^2 + r^3h = O(r^2h + r^2h^2 + r^3h)$. This can be simplified to $O(r^3)$ because there are typically a lot more residents than hospitals, so $r^3$ becomes the dominant term in the expression. 

\section{Variation of Hospitals and Residents Stable Matching Problem}
\subsection{The Algorithm}
One variation of the hospitals and residents stable matching problem is when only the residents rank the hospitals and the hospitals do not rank the residents. When making the assignments, stability is defined by not having a resident who is assigned to one hospital that would rather be in another hospital that is still available. Similar to the original algorithm, hospital capacity would be nice to have, but is not a necessity if not enough residents prefer the hospital to meet its capacity. In other words, overall resident happiness is the most important variable to consider when making the assignments. As displayed in Algorithm \ref{algorithm:variation}, the method needed to make the assignments requires a greedy approach and taking the first possible outcome that works for the data. It is for this reason that each resident is initially assigned to their top choice hospital and then gets trimmed down to meet the respective capacity of each hospital.

\begin{algorithm}
    \caption{Hospitals and Residents Stable Matching Algorithm}
    \label{algorithm:variation}
    %Documentation for algorithmicx: https://texdoc.org/serve/algorithmicx/0
    \begin{algorithmic}[1]
        \Procedure{StableMatchVariation}{$residents$, $hospitals$}
          \For{$r~of~residents$}
            \State $topHosp \gets r.preferences.head$
            \State $r.assignment \gets topHosp$ \Comment{Residents start with their top choice regardless of capacity}
          \EndFor
          \For{$i \gets 0, NUM\_LEVELS - 1$} \Comment{Have to check at all levels}
            \For{$j \gets 0, len(hospitals) - 1$} \Comment{Have to iterate through each hospital}
                \While{$hospitals[j].numAssigned(0, i) > hospitals[j].capacity$} \Comment{Continue until the hospital is no longer over capacity at the given level}
                    \State $res \gets hospitals[j].assignments[i].dequeue()$ \Comment{Get the resident being removed}
                    \State $res.preferences.dequeue()$ \Comment{Remove the hospital from the resident's preferences}
                    \If{$i < NUM\_LEVELS - 1$}
                        \State $newTopHospital \gets res.preferences.head$
                        \State $newTopHospital.assignments[i + 1].add{res}$ \Comment{Add the resident to their next top choice}
                    \EndIf
                \EndWhile
            \EndFor
          \EndFor
          \For{$i \gets 0, len(hospitals) - 1$}
            \For{$j \gets 0, NUM\_LEVELS - 1$} \Comment {Iterate through all the residents assigned to the hospital}
                \State $cur \gets hospitals[i].assignments[j].head$
                \While{$cur~!=~null$}
                    \State $cur.assignment \gets hospitals[i]$ \Comment{Formally assign the resident to the hospital}
                    \State $cur \gets cur.next$
                \EndWhile
            \EndFor
          \EndFor
          \State $swaps \gets -1$ \Comment{Initialize to -1 to enter the loop}
          \While{$swaps~!= 0$}
            \State $swaps \gets 0$ \Comment{Start off the iteration with 0 swaps}
            \For{$i \gets 0, len(residents) - 1$}
                \For{$j \gets i + 1, len(residents) - 1$} \Comment{Compare all residents to all residents}
                    \State $iHosp \gets residents[i].assignment$ \Comment{Get the current assignments}
                    \State $jHosp \gets residents[j].assignment$
                    \State $canSwap \gets true$ \Comment{Assume we can swap and end up with a stable pairing}
                    \If{$residents[i].rankings[jHosp.index]~!= 0$}
                        \State $canSwap \gets false$ \Comment{Cannot swap because resident i didn't rank jHosp}
                    \ElsIf{$residents[j].rankings[iHosp.index]~!= 0$}
                        \State $canSwap \gets false$ \Comment{Same but for resident j}
                    \EndIf
                    \If{$canSwap$}
                        \State $curHappiness \gets avg(residents[i].rankings[iHosp.index], residents[j].rankings[jHosp.index])$
                        \State $swapHappiness \gets avg(residents[i].rankings[jHosp.index], residents[j].rankings[iHosp.index])$
                        \If{swapHappiness > curHappiness} \Comment{Swapping would result in a better net happiness}
                            \State $iHosp.remove(residents[i])$ \Comment{Remove the residents from the hopsitals}
                            \State $jHosp.remove(residents[j])$

                            \State $iHosp.add(residents[j])$ \Comment{Swap the residents and the hospitals they are assigned to}
                            \State $residents[j].assignment \gets iHosp$
                            \State $jHosp.add(residents[i])$
                            \State $residents[i].assignment \gets jHosp$

                            \State $swaps \gets swaps + 1$ \Comment{Increment the number of swaps made}
                        \EndIf
                    \EndIf
                \EndFor
            \EndFor
          \EndWhile
        \EndProcedure
    \end{algorithmic}
  \end{algorithm}

\subsection{Asymptotic Analysis}
Listing \ref{lst:variation} provides the C++ implementation of the variation algorithm to the stable matching problem. First, lines 4-9 include a for-loop that assigns each resident to their top choice hospital, which is an $O(r)$ operation since the loop is iterating over each resident. Next, lines 16 and 17 define nested loops that iterate over each hospital for each level of assignments the hospitals have. Since the number of levels is a constant factor, the loop is just an $O(h)$ loop that is just being executed more than once. The while loop defined on line 19 contains a check to see if the hospital is over capacity in the given range, and the condition runs in constant time because both functions being called are constant time operations. However, based on the condition, the loop will run until the hospital is no longer over capacity, which means that enough residents have to be removed to meet the condition, making the loop an $O(r)$ loop. Lines 21 and 22 are both constant time dequeue operations. Inside the if-statement though, there is a call to the $priorityAdd$ function, which is an $O(r)$ function that has to iterate over the linked list to find the appropriate spot to place the element. Therefore, the nested loops on lines 16-33 run in $O(h * r * r) = O(hr^2)$. Since there are typically more residents than hospitals, the $r^2$ term dominates the expression and makes the loop run in $O(r^2)$ time. Next, the loops on lines 36-44 iterates through each hospital and assigns the appropriate residents to that hospital, which is the same thing as saying that each resident is formally assigned to a hospital. This is an $O(r)$ operation since each resident has to be considered. The last component of the algorithm is the swapping mechanism, which is defined on lines 68-145. First, the while-loop defined on line 69 continues until no swaps were made in the previous iteration. As the objective of the greedy algorithm was to get as high of a resident happiness score as possible, the number of times this loop runs should be minimal, which is why it is being classified as an added coefficient to the performance of the loop's body. Next, the nested for-loops defined on lines 72 and 73 set up each resident to be compared to the other residents, which is an $O(r^2)$ operation as the residents array has to be gone through for each pass of the outer loop. The entire body of the nested for-loops consists entirely of comparisons and assignments, which all runs in constant time. Therefore, the functionality of swapping elements runs in $O(r^2)$ time. Overall, when combining each component of the algorithm, the runtime for the variation algorithm is $r + r^2 + r^2 = r + 2r^2$ is $O(r^2)$.

\section{Appendix}
\lstset{numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=5pt}

% Colors and lstset for syntax highlighting from https://www.overleaf.com/latex/examples/syntax-highlighting-in-latex-with-the-listings-package/jxnppmxxvsvk
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{
  backgroundcolor=\color{white},   % choose the background color
  basicstyle=\footnotesize,        % size of fonts used for the code
  breaklines=true,                 % automatic line breaking only at whitespace
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  escapeinside={\%*}{*},          % if you want to add LaTeX within your code
  keywordstyle=\color{blue},       % keyword style
  stringstyle=\color{mymauve},     % string literal style
}

\subsection{Original Algorithm}
\lstinputlisting[caption = Original Stable Matching Algorithm (C++), label = lst:original, language = C++, firstline = 98, lastline = 184, firstnumber = 1]{./../original/stableMatching.cpp}

\subsection{Variation Algorithm}
\lstinputlisting[caption = Variation Stable Matching Algorithm (C++), label = lst:variation, language = C++, firstline = 112, lastline = 273, firstnumber = 1]{./../residentVariation/stableMatching.cpp}

\end{document}